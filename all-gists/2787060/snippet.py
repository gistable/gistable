# -*- coding:UTF8 -*-
#1.概念：
#	正则表达式（或 RE）是一种小型的、高度专业化的编程语言，
#      （在Python中）它内嵌在Python中，并通过 re 模块实现。使用这个小型语言，
#       你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、email
#       地址、TeX命令或任何你想搞定的东西。然后你可以问诸如“这个字符串匹配
#       该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE
#       以各种方式来修改或分割字符串。
#
#	正则表达式语言相对小型和受限（功能有限），因此并非所有字符串处理都能用
#       正则表达式完成。当然也有些任务可以用正则表达式完成，不过最终表达式会变
#       得异常复杂。碰到这些情形时，编写 Python 代码进行处理可能反而更好；尽管
#       Python 代码比一个精巧的正则表达式要慢些，但它更易理解。
#
#2.在正则表达式中， 如下的字符是具有特殊含义的
#	. (所有字符)  ^  $  *(0-N次)  +(1-N次)  ? (0-1次) { } [  ]  \  |  ( ) 
#       1)."[" 和 "]"。它们常用来指定一个字符类别，所谓字符类别就是你想匹配的一个字符集
#       2).其它地方的"^"只会简单匹配 "^"字符本身。例[^5] 将匹配除 "5" 之外的任意字符。
#       3).反斜杠后面可以加不同的字符以表示不同特殊意义。它也可以用于取消所有的元字符
#
#3.RE 函数用法:
#       findall(rule , target [,flag] ) 在目标字符串中查找符合规则的字符串。
#       match() 决定 RE 是否在字符串刚开始的位置匹配
#       search() 扫描字符串，找到这个 RE 匹配的位置
#       findall() 找到 RE 匹配的所有子串，并把它们作为一个列表返回
#       finditer() 找到 RE 匹配的所有子串，并把它们作为一个迭代器返回
#       group() 返回被 RE 匹配的字符串
#       start() 返回匹配开始的位置
#       end() 返回匹配结束的位置
#       span() 返回一个元组包含匹配 (开始,结束) 的位置
#       compile( rule [,flag] )将正则规则编译成一个Pattern对象，以供接下来使用第一个参数   
#
#                                   是规则式，第二个参数是规则选项。(使用compile加速)
#
#4 : 含义:
#	预定义转义字符集： “\d”  “\w” “\s” 等等，它们是以字符’\’开头，后面接一个特定
#
#字符的形式,用来指示一个预定义好的含义
#
#	‘^’  和’$’ 匹配字符串开头和结尾
#	‘.’    匹配所有字符 除\n以外
#	‘\d’  匹配数字
#	‘\D’  匹配非数字
#	‘\w’  匹配字母和数字
#	‘\W’  匹配非英文字母和数字
#	‘\s’   匹配间隔符
#	‘\S’   匹配非间隔符
#	‘\A’  匹配字符串开头
#	‘\Z’  匹配字符串结尾
#	‘\b’  只用以匹配单词的词首和词尾。单词被定义为一个字母数字序列，因此词尾就	
#
#                     是用空白符或非字母数字符来标示的。(退格)
#	‘\B’，它正好同 \b 相反，只在当前位置不在单词边界时匹配。
#5.前向界定与后向界定:
#	‘(?<=…)’ 前向界定:括号中’…’代表你希望匹配的字符串的前面应该出现的字符串。
#	‘(?=…)’后向界定    :括号中的’…’代表你希望匹配的字符串后面应该出现的字符串
#	‘(?<!..)’前向非界定 :只有当你希望的字符串前面不是’…’的内容时才匹配
#	‘(?!...)’后向非界定  :只有当你希望的字符串后面不跟着’…’内容时才匹配。
#6.组的基本知识:
#	‘(‘’)’                  无命名组                    [a-z]+(\d+)[a-z]+
#	‘(?P<name>…)’    命名组                    (?P<g1>[a-z]+)\d+(?P=g1)
#	‘(?P=name)’ 调用已匹配的命名组
#	‘\number’通过序号调用已匹配的组正则式中的每个组都有一个序号，序号是按组
#
#从左到右，从1开始的数字，你可以通过下面的形式来调用已匹配的组
#	                       		             ( r"(\d+)([a-z]+)(\d+)(\2)(\1)" )   
import sys
reload(sys)
sys.setdefaultencoding('utf-8')

import rhinoscriptsyntax as rs
# 正则表达式
import re
str1 = "abc \\ 123 456"
print re.findall("\\\\",str1)  # 不用r和用r的区
print re.findall(r"\d\Z",str1) # 用"r"来定义规则字符串

p = re.compile('(a)b')
m = p.match('ab')
print m.group()

s = "aaa1 22 gg 333 ccc 4444 pppp 55555 666"
print re.findall(r"\b\d{3}\b",s)
print re.findall(r"\b\d{2,4}\b",s)

s2 = "aaa111aaa , bbb222 , 333ccc"
print re.findall( r"(?<=[a-z]+)\d+(?=[a-z]+)",s2 )
print re.findall( r"\d+(?=[a-z]+)",s2 )
## 目标 前面是a-z 1-多次、中间数字1-9 1-多次
print re.findall(r"\d+(?!\w+)",s2)
#无命名组
print re.findall(r"[a-z]+(\d+)[a-z]+",s2) # 只返回()里面的
s3 = 'aaa111aaa,bbb222,333ccc,444ddd444,555eee666,fff777ggg,hhh888hhh'
print re.findall(r"([a-z]+)\d+([a-z]+)",s3) #返回括号里面的
#‘(?P<name>…)’ 命名组
print re.findall( r"(?P<g1>[a-z]+)\d+(?P=g1)",s3 ) #找出被中间夹有数字的前后同样的字母
print re.findall(r"([a-z]+)\d+\1",s3)
s4 = "111aaa222aaa111,333bbb444bb33"
print re.findall( r"(\d+)([a-z]+)(\d+)(\2)(\1)", s4 ) #数字、字母、数字、字母、数字相对称
print re.compile(r"(\d+)([a-z]+)(\d+)(\2)(\1)").findall(s4)

#compile( rule [,flag] ) 使用compile加速
s5 = "111,222,aaa,bbb,ccc333,444ddd"
print re.compile(r"\d+\b").findall(s5) # \退格 匹配一个位于开头的数字，没有使用M选项

s6 = "123 456\n789 012\n345 678"
print re.compile(r"^\d+",re.M).findall(s6) # 匹配位于(M/多行)开头的数字

rcm=re.compile(r"\d+$")# 对于’$’来说，没有使用M选项，它将匹配最后一个行尾的数字，即’678’，加上以后，就能匹配三个行尾的数字456 012和678了.
print re.compile(r"\d+$",re.M).findall(s6) # 







